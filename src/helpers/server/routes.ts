/* eslint-disable @typescript-eslint/no-explicit-any */
// This file is auto-generated by scripts/gen_route_helpers.ts
import { parseFromRequestRecord } from "@/helpers/server/zod_helpers";
import { redirect } from "next/navigation";
import { z } from "zod";

const toStringParam = (v: unknown) =>
  encodeURIComponent(typeof v === "string" ? v : JSON.stringify(v));
const toPathParams = <T extends { [key: string]: unknown }>(
  props: T,
  parts: Array<
    { part: keyof T & string; isParam: true } | { part: string; isParam: false }
  >,
) => {
  return Array.from(parts).flatMap(({ part, isParam }): string[] => {
    if (!isParam) return [part];
    const v = props[part as keyof T];
    if (v === undefined) return ["undefined"];
    if (Array.isArray(v)) return v.map(toStringParam);
    return [toStringParam(v)];
  });
};
const toSearchParams = <T extends { [key: string]: unknown }>(
  props: T,
  keys: Array<keyof T & string>,
) => {
  const result = Array.from(keys).flatMap((key): Array<string> => {
    const value = props[key];
    if (value === undefined) return [];
    if (Array.isArray(value))
      return value.map((e) => `${key}=${toStringParam(e)}`);
    return [`${key}=${toStringParam(value)}`];
  });
  if (result.length === 0) return "";
  return `?${result.join("&")}`;
};

// Corresponding to src/app/(root)/page.tsx
export const redirectToIndex = (): never => redirect("/");

// Corresponding to src/app/home/page.tsx
export const redirectToHome = (): never => redirect("/home");

// Corresponding to src/app/login/page.tsx
export const redirectToLogin = (props: import("/data/Work/HopeFlow/webapp/src/helpers/server/page_component").PageParams): never =>
  redirect(
    [
      "",
      ...toPathParams(props, [{ "part": "login", "isParam": false }]),
    ].join("/") + toSearchParams(props, ["params", "searchParams"]),
  );

// Corresponding to src/app/notifications/page.tsx
export const redirectToNotifications = (): never => redirect("/notifications");

// Corresponding to src/app/sample/page.tsx
export const redirectToSample = (): never => redirect("/sample");

// Corresponding to src/app/link/[linkCode]/page.tsx
export const redirectToLink = (props: { linkCode: any; }): never =>
  redirect(
    [
      "",
      ...toPathParams(props, [{ "part": "link", "isParam": false }, { "part": "linkCode", "isParam": true }]),
    ].join("/"),
  );

// Corresponding to src/app/quest/[questId]/page.tsx
export const redirectToQuest = (props: { questId: string; }): never =>
  redirect(
    [
      "",
      ...toPathParams(props, [{ "part": "quest", "isParam": false }, { "part": "questId", "isParam": true }]),
    ].join("/"),
  );
const routeSpecs: Map<
  "Index" | "Home" | "Login" | "Notifications" | "Sample" | "Link" | "Quest",
  {
    pathRegExp: RegExp;
    paramsTypeDef?: z.AnyZodObject;
    searchParamsTypeDef?: z.AnyZodObject;
    isPublic: boolean;
  }
> = new Map([
  ["Index", { pathRegExp: /^$/, paramsTypeDef: undefined, searchParamsTypeDef: undefined, isPublic: false }],
  ["Home", { pathRegExp: /^$/, paramsTypeDef: undefined, searchParamsTypeDef: undefined, isPublic: false }],
  ["Login", { pathRegExp: /^$/, paramsTypeDef: undefined, searchParamsTypeDef: z.object({ url: z.string().optional() }), isPublic: false }],
  ["Notifications", { pathRegExp: /^$/, paramsTypeDef: undefined, searchParamsTypeDef: undefined, isPublic: false }],
  ["Sample", { pathRegExp: /^$/, paramsTypeDef: undefined, searchParamsTypeDef: undefined, isPublic: false }],
  ["Link", { pathRegExp: /^$/, paramsTypeDef: z.object({ linkCode: z.string() }), searchParamsTypeDef: undefined, isPublic: false }],
  ["Quest", { pathRegExp: /^$/, paramsTypeDef: z.object({ questId: z.string() }), searchParamsTypeDef: undefined, isPublic: false }],
]);
const parseRouteFromUrl = (urlString: string) => {
  const url = new URL(urlString, "http://localhost");
  for (const [routeName, spec] of routeSpecs) {
    const match = url.pathname.match(spec.pathRegExp);
    if (!match) continue;
    if (spec.paramsTypeDef && !match.groups) continue;
    const params =
      spec.paramsTypeDef &&
      parseFromRequestRecord(match.groups!, spec.paramsTypeDef);
    const getValue = (v: string[]) => (v.length === 1 ? v[0] : v);
    const rawSearchParams = Object.fromEntries(
      url.searchParams
        .keys()
        .map((k) => [k, getValue(url.searchParams.getAll(k))]),
    );
    const searchParams =
      spec.searchParamsTypeDef &&
      parseFromRequestRecord(rawSearchParams, spec.searchParamsTypeDef);
    return { routeName, spec, params, searchParams };
  }
};
export const isValidUrl = (urlString: string): boolean => {
  const routeNameAndSpecs = parseRouteFromUrl(urlString);
  return !!routeNameAndSpecs;
};
export const isPublicUrl = (urlString: string): boolean => {
  const routeNameAndSpecs = parseRouteFromUrl(urlString);
  if (!routeNameAndSpecs) return false;
  return routeNameAndSpecs.spec.isPublic;
};
export const redirectTo = (urlString: string): never => {
  const routeNameAndSpecs = parseRouteFromUrl(urlString);
  if (!routeNameAndSpecs) throw new Error(`Invalid redirect url: ${urlString}`);
  const { routeName, params, searchParams } = routeNameAndSpecs;
  const props = { ...params, ...searchParams };
  switch (routeName) {
    case "Index": return redirectToIndex();
    case "Home": return redirectToHome();
    case "Login": return redirectToLogin(props as any);
    case "Notifications": return redirectToNotifications();
    case "Sample": return redirectToSample();
    case "Link": return redirectToLink(props as any);
    case "Quest": return redirectToQuest(props as any);
  }
};
